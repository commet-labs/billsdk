import {
  type CleanedWhere,
  type CustomAdapter,
  createAdapterFactory,
  type DBAdapter,
} from "@billsdk/core";
import type { SQL } from "drizzle-orm";
import {
  and,
  asc,
  desc,
  eq,
  gt,
  gte,
  inArray,
  like,
  lt,
  lte,
  ne,
} from "drizzle-orm";

/**
 * Drizzle database instance type
 */
export interface DrizzleDB {
  // biome-ignore lint/suspicious/noExplicitAny: Drizzle types vary by dialect
  insert: (table: any) => any;
  // biome-ignore lint/suspicious/noExplicitAny: Drizzle types vary by dialect
  select: () => any;
  // biome-ignore lint/suspicious/noExplicitAny: Drizzle types vary by dialect
  update: (table: any) => any;
  // biome-ignore lint/suspicious/noExplicitAny: Drizzle types vary by dialect
  delete: (table: any) => any;
  transaction?: <T>(fn: (tx: DrizzleDB) => Promise<T>) => Promise<T>;
}

/**
 * Drizzle adapter configuration
 */
export interface DrizzleAdapterConfig {
  /**
   * The schema object that defines the tables
   */
  // biome-ignore lint/suspicious/noExplicitAny: Schema varies by user's table definitions
  schema: Record<string, any>;

  /**
   * The database provider
   */
  provider: "pg" | "mysql" | "sqlite";

  /**
   * Enable debug logs
   * @default false
   */
  debugLogs?: boolean;

  /**
   * Enable transaction support
   * @default true
   */
  transaction?: boolean;
}

/**
 * Build where clause from CleanedWhere[] format
 */
// biome-ignore lint/suspicious/noExplicitAny: Table type varies by user's schema
function buildWhereClause(where: CleanedWhere[], table: any): SQL | undefined {
  if (!where || where.length === 0) return undefined;

  const conditions: SQL[] = [];

  for (const clause of where) {
    const column = table[clause.field];
    if (!column) continue;

    let condition: SQL | undefined;

    switch (clause.operator) {
      case "eq":
        condition = eq(column, clause.value);
        break;
      case "ne":
        condition = ne(column, clause.value);
        break;
      case "gt":
        condition = gt(column, clause.value as number);
        break;
      case "gte":
        condition = gte(column, clause.value as number);
        break;
      case "lt":
        condition = lt(column, clause.value as number);
        break;
      case "lte":
        condition = lte(column, clause.value as number);
        break;
      case "in":
        if (Array.isArray(clause.value)) {
          condition = inArray(column, clause.value);
        }
        break;
      case "contains":
        condition = like(column, `%${clause.value}%`);
        break;
      case "startsWith":
        condition = like(column, `${clause.value}%`);
        break;
      case "endsWith":
        condition = like(column, `%${clause.value}`);
        break;
    }

    if (condition) {
      conditions.push(condition);
    }
  }

  if (conditions.length === 0) return undefined;
  if (conditions.length === 1) return conditions[0];

  return and(...conditions);
}

/**
 * Create a Drizzle ORM adapter for BillSDK
 *
 * @example
 * ```typescript
 * import { drizzleAdapter } from "@billsdk/drizzle-adapter";
 * import { db } from "./db";
 * import * as schema from "./billing-schema"; // Generated by CLI
 *
 * const adapter = drizzleAdapter(db, {
 *   schema,
 *   provider: "pg",
 * });
 * ```
 */
export function drizzleAdapter(
  db: DrizzleDB,
  config: DrizzleAdapterConfig,
): DBAdapter {
  // Create the custom adapter function
  const createCustomAdapter = (txDb: DrizzleDB): CustomAdapter => {
    const getTable = (model: string) => {
      const table = config.schema[model];
      if (!table) {
        throw new Error(`Table "${model}" not found in schema`);
      }
      return table;
    };

    const withReturning = async (
      // biome-ignore lint/suspicious/noExplicitAny: Query builder type varies by operation
      builder: any,
      model: string,
      where?: CleanedWhere[],
      // biome-ignore lint/suspicious/noExplicitAny: Return type varies by table schema
    ): Promise<any> => {
      if (config.provider !== "mysql") {
        const result = await builder.returning();
        return result[0];
      }

      // MySQL doesn't support RETURNING, so we need to fetch after
      await builder.execute();

      if (where) {
        const table = getTable(model);
        const clause = buildWhereClause(where, table);
        const [result] = await txDb.select().from(table).where(clause);
        return result;
      }

      return null;
    };

    return {
      async create<T extends Record<string, unknown>>(data: {
        model: string;
        data: Record<string, unknown>;
        select?: string[];
      }): Promise<T> {
        const table = getTable(data.model);
        const builder = txDb.insert(table).values(data.data);

        if (config.provider !== "mysql") {
          const [result] = await builder.returning();
          return result as T;
        }

        await builder.execute();

        // Fetch the inserted record for MySQL
        const id = data.data.id;
        const [result] = await txDb
          .select()
          .from(table)
          .where(eq(table.id, id));

        return result as T;
      },

      async findOne<T extends Record<string, unknown>>(data: {
        model: string;
        where: CleanedWhere[];
        select?: string[];
      }): Promise<T | null> {
        const table = getTable(data.model);
        const clause = buildWhereClause(data.where, table);

        const query = txDb.select().from(table);
        const results = clause ? await query.where(clause) : await query;

        return (results[0] as T) ?? null;
      },

      async findMany<T extends Record<string, unknown>>(data: {
        model: string;
        where?: CleanedWhere[];
        select?: string[];
        limit?: number;
        offset?: number;
        sortBy?: { field: string; direction: "asc" | "desc" };
      }): Promise<T[]> {
        const table = getTable(data.model);
        let query = txDb.select().from(table);

        // Apply where
        if (data.where && data.where.length > 0) {
          const clause = buildWhereClause(data.where, table);
          if (clause) {
            query = query.where(clause);
          }
        }

        // Apply sorting
        if (data.sortBy) {
          const column = table[data.sortBy.field];
          if (column) {
            query = query.orderBy(
              data.sortBy.direction === "desc" ? desc(column) : asc(column),
            );
          }
        }

        // Apply pagination
        if (data.limit) {
          query = query.limit(data.limit);
        }
        if (data.offset) {
          query = query.offset(data.offset);
        }

        const results = await query;
        return results as T[];
      },

      async update<T extends Record<string, unknown>>(data: {
        model: string;
        where: CleanedWhere[];
        update: Record<string, unknown>;
      }): Promise<T | null> {
        const table = getTable(data.model);
        const clause = buildWhereClause(data.where, table);

        const builder = txDb.update(table).set(data.update);

        if (clause) {
          builder.where(clause);
        }

        const result = await withReturning(builder, data.model, data.where);
        return result as T;
      },

      async updateMany(data: {
        model: string;
        where: CleanedWhere[];
        update: Record<string, unknown>;
      }): Promise<number> {
        const table = getTable(data.model);
        const clause = buildWhereClause(data.where, table);

        const builder = txDb.update(table).set(data.update);

        if (clause) {
          builder.where(clause);
        }

        const result = await builder.execute();

        // Return count based on provider
        if ("rowCount" in result) return result.rowCount ?? 0;
        if ("affectedRows" in result) return result.affectedRows ?? 0;
        if ("changes" in result) return result.changes ?? 0;

        return 0;
      },

      async delete(data: {
        model: string;
        where: CleanedWhere[];
      }): Promise<void> {
        const table = getTable(data.model);
        const clause = buildWhereClause(data.where, table);

        const builder = txDb.delete(table);

        if (clause) {
          builder.where(clause);
        }

        await builder.execute();
      },

      async deleteMany(data: {
        model: string;
        where: CleanedWhere[];
      }): Promise<number> {
        const table = getTable(data.model);
        const clause = buildWhereClause(data.where, table);

        const builder = txDb.delete(table);

        if (clause) {
          builder.where(clause);
        }

        const result = await builder.execute();

        // Return count based on provider
        if ("rowCount" in result) return result.rowCount ?? 0;
        if ("affectedRows" in result) return result.affectedRows ?? 0;
        if ("changes" in result) return result.changes ?? 0;

        return 0;
      },

      async count(data: {
        model: string;
        where?: CleanedWhere[];
      }): Promise<number> {
        const table = getTable(data.model);
        let query = txDb.select().from(table);

        if (data.where && data.where.length > 0) {
          const clause = buildWhereClause(data.where, table);
          if (clause) {
            query = query.where(clause);
          }
        }

        const results = await query;
        return results.length;
      },

      options: {
        provider: config.provider,
        schema: config.schema,
      },
    };
  };

  // Use the adapter factory and immediately invoke it
  return createAdapterFactory({
    config: {
      adapterId: "drizzle",
      adapterName: "Drizzle Adapter",
      supportsJSON: config.provider === "pg",
      supportsDates: true,
      supportsBooleans: config.provider !== "sqlite",
      supportsArrays: config.provider === "pg",
      debugLogs: config.debugLogs ?? false,
      transaction:
        config.transaction !== false && db.transaction
          ? async <R>(callback: (adapter: DBAdapter) => Promise<R>) => {
              return db.transaction!(async (tx) => {
                const txAdapter = createAdapterFactory({
                  config: {
                    adapterId: "drizzle",
                    supportsJSON: config.provider === "pg",
                    supportsDates: true,
                    supportsBooleans: config.provider !== "sqlite",
                    supportsArrays: config.provider === "pg",
                  },
                  adapter: (_helpers) => createCustomAdapter(tx as DrizzleDB),
                })({});
                return callback(txAdapter);
              });
            }
          : false,
    },
    adapter: (_helpers) => createCustomAdapter(db),
  })({});
}
